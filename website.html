<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Tail Latency Plot</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        #dropzone {
            border: 2px dashed #999;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            background: #f8f8f8;
        }

        #dropzone.dragover {
            background: #d0f0d0;
            border-color: #3a3;
        }

        #fileInput {
            display: none;
        }

        button {
            margin-top: 10px;
            padding: 10px 15px;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <h2>Tail Latency Plot</h2>
    <div id="dropzone">
        Drag & drop one or more <b>.json</b> files anywhere on this window<br>
        or <button id="pickBtn">Select Files</button>
        <input type="file" id="fileInput" multiple accept=".json">
    </div>
    <div id="plot" style="width: 100%; height: 500px;"></div>

    <script>
        let allTraces = [];
        let globalMaxLatency = 0;

        /**
         * Downsample based on log spacing of tail probability (1 - p)
         */
        function computeTailCDFLogSpaced(data, maxPoints = 1000) {
            data.sort((a, b) => a - b);
            const n = data.length;

            // Generate log-spaced probabilities between ~1 and ~1/n
            const minTail = 1 / n;
            const maxTail = 1;
            const logMin = Math.log10(minTail);
            const logMax = Math.log10(maxTail);

            const probs = [];
            const latencies = [];
            for (let i = 0; i < maxPoints; i++) {
                const logPos = logMax - (i * (logMax - logMin) / (maxPoints - 1)); // decreasing
                const tailProb = Math.pow(10, logPos);
                const rank = Math.max(0, Math.min(n - 1, Math.floor(n * (1 - tailProb))));
                probs.push(tailProb);
                latencies.push(data[rank]);
            }

            return { probs, latencies };
        }

        function chooseUnit(maxValue) {
            if (maxValue < 1e3) return { factor: 1, unit: 'ns' };
            if (maxValue < 1e6) return { factor: 1e-3, unit: 'Âµs' };
            if (maxValue < 1e9) return { factor: 1e-6, unit: 'ms' };
            return { factor: 1e-9, unit: 's' };
        }

        function updatePlot() {
            const { factor, unit } = chooseUnit(globalMaxLatency);

            const scaledTraces = allTraces.map(trace => ({
                x: trace.x,
                y: trace.y.map(v => v * factor),
                text: trace.x.map((p, i) => {
                    const percentile = (1 - p) * 100;
                    const rawNs = trace.y[i];
                    const scaledVal = (rawNs * factor).toFixed(3);
                    return `Percentile: ${percentile.toFixed(3)}%<br>` +
                        `Latency: ${scaledVal} ${unit}<br>` +
                        `Original: ${rawNs} ns`;
                }),
                hoverinfo: 'text',
                name: trace.name,
                mode: 'lines'
            }));

            Plotly.newPlot('plot', scaledTraces, {
                title: `Tail Latency Plot (${unit})`,
                xaxis: {
                    title: 'Percentile',
                    type: 'log',
                    autorange: 'reversed',
                    tickvals: [1e-6, 1e-4, 1e-3, 1e-2, 1e-1, 0.5, 1],
                    ticktext: ['~100%', '99.99%', '99.9%', '99%', '90%', '50%', '0%']
                },
                yaxis: { title: `Latency (${unit})` }
            });
        }

        async function handleFiles(fileList) {
            for (const file of fileList) {
                if (!file.name.endsWith('.json')) {
                    alert(`Skipping ${file.name}: not a .json file`);
                    continue;
                }

                const text = await file.text();
                const latencies = JSON.parse(text);
                if (!Array.isArray(latencies)) {
                    alert(`Skipping ${file.name}: invalid JSON array`);
                    continue;
                }

                const { probs, latencies: sampledLatencies } = computeTailCDFLogSpaced(latencies);
                globalMaxLatency = Math.max(globalMaxLatency, ...sampledLatencies);

                allTraces.push({
                    x: probs,
                    y: sampledLatencies,
                    name: file.name
                });
            }

            updatePlot();
        }

        // Drag-and-drop anywhere
        const dropzone = document.getElementById('dropzone');
        window.addEventListener('dragover', e => {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });
        window.addEventListener('dragleave', e => {
            dropzone.classList.remove('dragover');
        });
        window.addEventListener('drop', e => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        // File picker
        const pickBtn = document.getElementById('pickBtn');
        const fileInput = document.getElementById('fileInput');
        pickBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', () => handleFiles(fileInput.files));
    </script>
</body>

</html>
